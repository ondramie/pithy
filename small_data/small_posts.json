{
    "@Id": "2",
    "@PostTypeId": "1",
    "@AcceptedAnswerId": "28",
    "@CreationDate": "2012-03-06T19:06:05.667",
    "@Score": "18",
    "@ViewCount": "510",
    "@Body": "<p>The set difference operator (e.g., <code>EXCEPT</code> in some SQL variants) is one of the many fundamental operators of relational algebra. However, there are some databases that do not support the set difference operator directly, but which support <code>LEFT JOIN</code> (a kind of outer join), and in practice this can be used instead of a set difference operation to achieve the same effect.</p>\n\n<p>Does this mean that the expressive power of a query language is the same even without the set difference operator, so long as the <code>LEFT JOIN</code> operator is maintained? How would one prove this fact?</p>\n",
    "@OwnerUserId": "5",
    "@LastEditorUserId": "69",
    "@LastEditDate": "2012-04-02T15:35:05.827",
    "@LastActivityDate": "2013-05-29T00:50:34.590",
    "@Title": "Does the 'difference' operation add expressiveness to a query language that already includes 'join'?",
    "@Tags": "<database-theory><relational-algebra><finite-model-theory>",
    "@AnswerCount": "2",
    "@CommentCount": "1",
    "@FavoriteCount": "1"
}{
    "@Id": "3",
    "@PostTypeId": "1",
    "@AcceptedAnswerId": "90",
    "@CreationDate": "2012-03-06T19:11:07.127",
    "@Score": "279",
    "@ViewCount": "262839",
    "@Body": "<p>In a standard algorithms course we are taught that <strong>quicksort</strong> is $O(n \\log n)$ on average and $O(n^2)$ in the worst case. At the same time, other sorting algorithms are studied which are $O(n \\log n)$ in the worst case (like <strong>mergesort</strong> and <strong>heapsort</strong>), and even linear time in the best case (like <strong>bubblesort</strong>) but with some additional needs of memory.</p>\n\n<p>After a quick glance at <a href=\"http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms\">some more running times</a> it is natural to say that quicksort <strong>should not</strong> be as efficient as others.</p>\n\n<p>Also, consider that students learn in basic programming courses that recursion is not really good in general because it could use too much memory, etc. Therefore (and even though this is not a real argument), this gives the idea that quicksort might not be really good because it is a recursive algorithm.</p>\n\n<p><strong>Why, then, does quicksort outperform other sorting algorithms in practice?</strong> Does it have to do with the structure of <em>real-world data</em>? Does it have to do with the way memory works in computers? I know that some memories are way faster than others, but I don't know if that's the real reason for this counter-intuitive performance (when compared to theoretical estimates).</p>\n\n<hr>\n\n<p><strong>Update 1:</strong> a canonical answer is saying that the constants involved in the $O(n\\log n)$ of the average case are smaller than the constants involved in other $O(n\\log n)$ algorithms. However, I have yet to see a proper justification of this, with precise calculations instead of intuitive ideas only.</p>\n\n<p>In any case, it seems like the real difference occurs, as some answers suggest, at memory level, where implementations take advantage of the internal structure of computers, using, for example, that cache memory is faster than RAM. The discussion is already interesting, but I'd still like to see more detail with respect to memory-management, since it appears that <em>the</em> answer has to do with it.</p>\n\n<hr>\n\n<p><strong>Update 2:</strong> There are several web pages offering a comparison of sorting algorithms, some fancier than others (most notably <a href=\"http://www.sorting-algorithms.com/\">sorting-algorithms.com</a>). Other than presenting a nice visual aid, this approach does not answer my question.</p>\n",
    "@OwnerUserId": "24",
    "@LastEditorUserId": "24",
    "@LastEditDate": "2012-03-23T13:15:39.290",
    "@LastActivityDate": "2016-10-18T16:08:51.713",
    "@Title": "Why is quicksort better than other sorting algorithms in practice?",
    "@Tags": "<algorithms><sorting>",
    "@AnswerCount": "11",
    "@CommentCount": "14",
    "@FavoriteCount": "192"
}{
    "@Id": "5",
    "@PostTypeId": "1",
    "@AcceptedAnswerId": "12",
    "@CreationDate": "2012-03-06T19:17:48.460",
    "@Score": "18",
    "@ViewCount": "1350",
    "@Body": "<p>Many operating systems references say that with cooperative (as opposed to preemptive) multitasking, a process keeps the CPU until it explicitly voluntarily suspends itself.  If a running process performs an I/O request that cannot be immediately satisfied (e.g., requests a key stroke that is not yet available), does the scheduler suspend it, or does it really keep the CPU until the request can be serviced?</p>\n\n<p>[Edited to replace \"blocks on i/o\" with \"performs an I/O request that cannot be immediately satisfied.\"]</p>\n",
    "@OwnerUserId": "40",
    "@LastEditorUserId": "98",
    "@LastEditDate": "2012-04-07T13:42:43.093",
    "@LastActivityDate": "2012-04-09T22:15:05.277",
    "@Title": "Does cooperative scheduling suspend processes when they perform an  I/O operation?",
    "@Tags": "<operating-systems><process-scheduling>",
    "@AnswerCount": "4",
    "@CommentCount": "2",
    "@FavoriteCount": "0"
}{
    "@Id": "6",
    "@PostTypeId": "2",
    "@ParentId": "3",
    "@CreationDate": "2012-03-06T19:19:20.237",
    "@Score": "17",
    "@Body": "<p>In comparison to other comparison-based sorting algorithms with $O(n \\lg n)$ time complexity, quick-sort is often considered to better than other algorithms like merge-sort because it is an in-place sorting algorithm. In other words, we don't need (much more) memory to store the members of the array.</p>\n\n<p>ps: to be precise, being better than other algorithms is task dependent. For some tasks it might be better to use other sorting algorithms.</p>\n\n<p>See also:</p>\n\n<ul>\n<li><p><a href=\"http://en.wikipedia.org/wiki/Quicksort#Comparison_with_other_sorting_algorithms\">Comparison of quick-sort with other sorting algorithms</a></p></li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/Heapsort#Comparison_with_other_sorts\">Comparison of heap-sort with other sorting algorithms</a></p></li>\n</ul>\n",
    "@OwnerUserId": "41",
    "@LastEditorUserId": "41",
    "@LastEditDate": "2012-03-06T22:18:33.027",
    "@LastActivityDate": "2012-03-06T22:18:33.027",
    "@CommentCount": "13"
}{
    "@Id": "7",
    "@PostTypeId": "1",
    "@CreationDate": "2012-03-06T19:34:22.793",
    "@Score": "15",
    "@ViewCount": "195",
    "@Body": "<p>When placing geometric objects in a quadtree (or octree), you can place objects that are larger than a single node in a few ways:</p>\n\n<ol>\n<li>Placing the object's reference in every leaf for which it is contained</li>\n<li>Placing the object's reference in the deepest node for which it is fully contained</li>\n<li>Both #1 and #2</li>\n</ol>\n\n<p>For example:</p>\n\n<p><img src=\"https://i.stack.imgur.com/Z2Bj7.jpg\" alt=\"enter image description here\"></p>\n\n<p>In this image, you could either place the circle in all four of the leaf nodes (method #1) or in just the root node (method #2) or both (method #3).</p>\n\n<p>For the purposes of querying the quadtree, which method is more commonplace and why?</p>\n",
    "@OwnerUserId": "11",
    "@LastEditorUserId": "11",
    "@LastEditDate": "2012-03-06T19:47:07.427",
    "@LastActivityDate": "2012-03-06T20:22:05.510",
    "@Title": "Which method is preferred for storing large geometric objects in a quadtree?",
    "@Tags": "<graphics><data-structures><computational-geometry>",
    "@AnswerCount": "2",
    "@CommentCount": "5"
}{
    "@Id": "9",
    "@PostTypeId": "2",
    "@ParentId": "7",
    "@CreationDate": "2012-03-06T19:44:17.600",
    "@Score": "7",
    "@Body": "<p>Assuming you are storing a reference, not the object itself, it may make sense to do this differently depending on your application.</p>\n\n<p>For instance, if you were computing collisions with this (solid) circle and the collision was occurring in the lower left hand corner, it'd be easier if you had access to all geometry in that leaf directly from that leaf (method #3) (without having to traverse the tree upward and determine inherited geometry). But, say you were just using quadtrees for drawing geometry, you'd want to use method #1, because it only makes sense to draw something in the node for which it is fully contained (it would be more difficult to figure out which portion to draw for each leaf node and where).</p>\n\n<p>As for what is more commonplace, my only experience with quadtrees is with writing an n-body simulation where the geometric objects were really just points that had no area, so I can't definitively answer that.</p>\n",
    "@OwnerUserId": "44",
    "@LastActivityDate": "2012-03-06T19:44:17.600",
    "@CommentCount": "1"
}{
    "@Id": "10",
    "@PostTypeId": "2",
    "@ParentId": "3",
    "@CreationDate": "2012-03-06T19:48:00.343",
    "@Score": "31",
    "@Body": "<p>I think one of the main reasons why QuickSort is so fast compared with other sorting algorithms is because it's cache-friendly. When QS processes a segment of an array, it accesses elements at the beginning and end of the segment, and moves towards the center of the segment.</p>\n\n<p>So, when you start, you access the first element in the array and a piece of memory (\u201clocation\u201d) is loaded into the cache. And when you try to access the second element, it's (most likely) already in the cache, so it's very fast.</p>\n\n<p>Other algorithms like heapsort don't work like this, they jump in the array a lot, which makes them slower.</p>\n",
    "@OwnerUserId": "29",
    "@LastActivityDate": "2012-03-06T19:48:00.343",
    "@CommentCount": "6"
}